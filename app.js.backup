// Storage key for local storage
const STORAGE_KEY = 'priorityItems';
const APP_STATE_KEY = 'appState';

// ============================================================================
// REFACTORING: Constants and Centralized Configuration
// ============================================================================

// Step 1: Constants for Categories and Levels
const CATEGORIES = ['urgency', 'value', 'duration'];
const LEVELS = [1, 2, 3];

// Step 2: Centralized Bucket Defaults
const BUCKET_DEFAULTS = {
        urgency: {
        1: { 
            limit: 30, 
            count: 0, 
            overLimit: false, 
            weight: 1,
            title: 'WHENEVER',
            description: '"Whenever" represents the lowest band of urgency. What this means is that the total value isn\'t massively affected by delay. Most cost-reducing initiatives would normally fall into this band. Other initiatives where there is little or no competition, might also initially fall in this band.'
        },
        2: { 
            limit: 30, 
            count: 0, 
            overLimit: false, 
            weight: 2,
            title: 'SOON',
            description: '"Soon" represents the middle band of urgency. If we don\'t deliver this Soon, then the value will start to decline or the risk of loss increase - reduced market share, reduced opportunity size. Whether Soon means in a matter of days, weeks or months you will need to decide for your context, given the distribution of urgency you are dealing with.'
        },
        3: { 
            limit: 30, 
            count: 0, 
            overLimit: false, 
            weight: 3,
            title: 'ASAP',
            description: '"ASAP" represents the highest band of urgency. If we don\'t deliver this ASAP, then the value (whatever total value that might be) will quickly evaporate - someone will get there before us or the opportunity (however big or small) will be massively impaired.'
        }
    },
    value: {
        1: { 
            limit: 30, 
            count: 0, 
            overLimit: false, 
            weight: 1,
            title: 'MEH',
            description: '"Meh" represents the lowest total value band. This is the pocket change stuff. The things that are still valuable and worth our time and effort doing, but they\'re not the sort of thing that customers are likely to rave about - more maintenance-level stuff. This is the work that keeps the lights on but won\'t get anyone too excited or move the needle significantly.'
        },
        2: { 
            limit: 30, 
            count: 0, 
            overLimit: false, 
            weight: 2,
            title: 'BONUS',
            description: '"Bonus" represents the middle band of total value. What this means will be context dependent (of course), but I\'m meaning it in a couple of different ways. Bonus could be those delighting things that we would want to tell our Customers about, perhaps even worth writing a press release for (try writing it before you start development). Customers will (hopefully) like it enough to give us money, or if they are already customers, to stay with us. The other way to think about it, would be that this is valuable enough that if we deliver this (and it works) we\'ll grow revenues or reduce costs enough for us all to "make bonus" for the year!'
        },
        3: { 
            limit: 30, 
            count: 0, 
            overLimit: false, 
            weight: 3,
            title: 'KILLER',
            description: '"Killer" represents the highest band of total value. These are the few things where if we do them, we stand to make an absolute killing, or; if we don\'t do something, it will probably kill us. (The challenge, as with all relative/qualitative approaches, is to try and avoid inflation)'
        }
    },
    duration: {
        1: { 
            limit: null, 
            count: 0, 
            overLimit: false, 
            weight: 1,
            title: '1-3d',
            description: 'TBD'
        },
        2: { 
            limit: null, 
            count: 0, 
            overLimit: false, 
            weight: 2,
            title: '1-3w',
            description: 'TBD'
        },
        3: { 
            limit: null, 
            count: 0, 
            overLimit: false, 
            weight: 3,
            title: '1-3mo',
            description: 'TBD'
        }
    }
};

// Step 5: Centralize Property Metadata
const PROPERTY_META = {
    urgency: { stage: 'urgency', prerequisites: [] },
    value: { stage: 'value', prerequisites: ['urgency'] },
    duration: { stage: 'duration', prerequisites: ['value'] }
};

// Stage Controller: Manages stage progression
const STAGE_ORDER = ['Item Listing', 'urgency', 'value', 'duration', 'Results', 'CD3'];
const STAGE_CONTROLLER = {
    getCurrentStage: (state) => state.currentStage || 'Item Listing',
    setCurrentStage: (state, stage) => {
        state.currentStage = stage;
    },
    getNextStage: (currentStage) => {
        const currentIndex = STAGE_ORDER.indexOf(currentStage);
        if (currentIndex === -1 || currentIndex >= STAGE_ORDER.length - 1) {
            return null; // Already at last stage
        }
        return STAGE_ORDER[currentIndex + 1];
    },
    getPreviousStage: (currentStage) => {
        const currentIndex = STAGE_ORDER.indexOf(currentStage);
        if (currentIndex <= 0) {
            return null; // Already at first stage
        }
        return STAGE_ORDER[currentIndex - 1];
    },
    canAdvance: (currentStage, items) => {
        const nextStage = STAGE_CONTROLLER.getNextStage(currentStage);
        if (!nextStage) return { canAdvance: false, reason: 'Already at the final stage' };
        
        // Special case: Item Listing -> Urgency: Must have at least one item
        if (currentStage === 'Item Listing') {
            if (items.length === 0) {
                return {
                    canAdvance: false,
                    reason: 'You must have at least one item before advancing to Urgency stage.'
                };
            }
            return { canAdvance: true };
        }
        
        // Special case: Duration -> Results: All items must have urgency, value, and duration
        if (currentStage === 'duration' && nextStage === 'Results') {
            if (items.length === 0) {
                return {
                    canAdvance: false,
                    reason: 'You must have at least one item before advancing to Results.'
                };
            }
            // Check all items have urgency, value, and duration
            const itemsWithoutUrgency = items.filter(item => !item.urgency || item.urgency === 0);
            const itemsWithoutValue = items.filter(item => !item.value || item.value === 0);
            const itemsWithoutDuration = items.filter(item => !item.duration || item.duration === 0);
            
            if (itemsWithoutUrgency.length > 0) {
                return {
                    canAdvance: false,
                    reason: `All items must have urgency, value, and duration set. ${itemsWithoutUrgency.length} item(s) still need urgency values.`
                };
            }
            if (itemsWithoutValue.length > 0) {
                return {
                    canAdvance: false,
                    reason: `All items must have urgency, value, and duration set. ${itemsWithoutValue.length} item(s) still need value values.`
                };
            }
            if (itemsWithoutDuration.length > 0) {
                return {
                    canAdvance: false,
                    reason: `All items must have urgency, value, and duration set. ${itemsWithoutDuration.length} item(s) still need duration values.`
                };
            }
            return { canAdvance: true };
        }
        
        // Check 1: Must have at least one item before advancing from any other stage
        if (items.length === 0) {
            return {
                canAdvance: false,
                reason: 'You must have at least one item before advancing stages.'
            };
        }
        
        // Check 2: All items must have values for current stage
        if (items.length > 0) {
            if (currentStage === 'urgency') {
                const itemsWithoutUrgency = items.filter(item => !item.urgency || item.urgency === 0);
                if (itemsWithoutUrgency.length > 0) {
                    return {
                        canAdvance: false,
                        reason: `All items must have urgency values set. ${itemsWithoutUrgency.length} item(s) still need urgency values.`
                    };
                }
            } else if (currentStage === 'value') {
                const itemsWithoutValue = items.filter(item => !item.value || item.value === 0);
                if (itemsWithoutValue.length > 0) {
                    return {
                        canAdvance: false,
                        reason: `All items must have value values set. ${itemsWithoutValue.length} item(s) still need value values.`
                    };
                }
            } else if (currentStage === 'duration') {
                const itemsWithoutDuration = items.filter(item => !item.duration || item.duration === 0);
                if (itemsWithoutDuration.length > 0) {
                    return {
                        canAdvance: false,
                        reason: `All items must have duration values set. ${itemsWithoutDuration.length} item(s) still need duration values.`
                    };
                }
            }
        }
        
        return { canAdvance: true };
    },
    canGoBack: (currentStage) => {
        return STAGE_CONTROLLER.getPreviousStage(currentStage) !== null;
    },
    // Get button states for UI
    getButtonStates: (currentStage, items) => {
        const canAdvanceResult = STAGE_CONTROLLER.canAdvance(currentStage, items);
        const canGoBackResult = STAGE_CONTROLLER.canGoBack(currentStage);
        
        return {
            canAdvance: canAdvanceResult.canAdvance,
            canGoBack: canGoBackResult,
            advanceReason: canAdvanceResult.reason || null,
            backReason: canGoBackResult ? null : 'Already at the first stage (Urgency)'
        };
    }
};

// Field validation rules
const FIELD_VALIDATORS = {
    limit: (value) => {
        if (!Number.isInteger(value) || value < 0) {
            return { valid: false, error: `Limit must be a non-negative integer (0 or greater). You entered: ${value}` };
        }
        return { valid: true };
    },
    weight: (value) => {
        if (isNaN(value) || value < 0) {
            return { valid: false, error: `Weight must be a non-negative number (0 or greater). You entered: ${value}` };
        }
        return { valid: true };
    },
    title: (value) => {
        if (!value || typeof value !== 'string' || value.trim().length === 0) {
            return { valid: false, error: `Title must be a non-empty string. You entered: ${value}` };
        }
        return { valid: true, processed: value.trim() };
    },
    description: (value) => {
        if (typeof value !== 'string') {
            return { valid: false, error: `Description must be a string. You entered: ${value}` };
        }
        return { valid: true };
    }
};

// Command form configurations
const COMMAND_FORMS = {
    startApp: {
        fields: [],
        handler: () => {
            startApp();
            return true;
        }
    },
    advanceStage: {
        fields: [],
        handler: () => {
            const result = advanceStage();
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    backStage: {
        fields: [],
        handler: () => {
            const result = backStage();
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    addItem: {
        fields: [
            {
                name: 'name',
                label: 'Item Name',
                type: 'text',
                required: true,
                placeholder: 'Enter item name'
            }
        ],
        handler: (formData) => {
            const result = addItem(formData.name);
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    bulkAddItems: {
        fields: [
            {
                name: 'itemNames',
                label: 'Item Names (one per line)',
                type: 'textarea',
                required: true,
                placeholder: 'Enter item names, one per line:\nItem 1\nItem 2\nItem 3'
            }
        ],
        handler: (formData) => {
            const result = bulkAddItems(formData.itemNames);
            if (!result.success) {
                alert(result.error);
                return false;
            }
            // Only show alert if there were errors (partial failures)
            if (result.errors && result.errors.length > 0) {
                alert(`Added ${result.added} item(s), but encountered errors:\n${result.errors.join('\n')}`);
            }
            return true;
        }
    },
    setItemActive: {
        fields: [
            {
                name: 'itemId',
                label: 'Item',
                type: 'select',
                required: true,
                options: () => {
                    const items = getItems();
                    return items.map(item => ({
                        value: item.id,
                        label: `${item.name} (${item.active !== false ? 'Active' : 'Inactive'})`
                    }));
                }
            }
        ],
        handler: (formData) => {
            const result = setItemActive(formData.itemId);
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    setItemInactive: {
        fields: [
            {
                name: 'itemId',
                label: 'Item',
                type: 'select',
                required: true,
                options: () => {
                    const items = getItems();
                    return items.map(item => ({
                        value: item.id,
                        label: `${item.name} (${item.active !== false ? 'Active' : 'Inactive'})`
                    }));
                }
            }
        ],
        handler: (formData) => {
            const result = setItemInactive(formData.itemId);
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    setUrgency: {
        fields: [
            {
                name: 'itemId',
                label: 'Select Item',
                type: 'select',
                required: true,
                options: () => getItems().map(item => ({ value: item.id, label: item.name }))
            },
            {
                name: 'urgency',
                label: 'Urgency',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            }
        ],
        handler: (formData) => {
            const result = setItemProperty(formData.itemId, 'urgency', parseInt(formData.urgency));
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    setValue: {
        fields: [
            {
                name: 'itemId',
                label: 'Select Item',
                type: 'select',
                required: true,
                options: () => getItems().map(item => ({ value: item.id, label: item.name }))
            },
            {
                name: 'value',
                label: 'Value',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            }
        ],
        handler: (formData) => {
            const result = setItemProperty(formData.itemId, 'value', parseInt(formData.value));
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    setDuration: {
        fields: [
            {
                name: 'itemId',
                label: 'Select Item',
                type: 'select',
                required: true,
                options: () => getItems().map(item => ({ value: item.id, label: item.name }))
            },
            {
                name: 'duration',
                label: 'Duration',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            }
        ],
        handler: (formData) => {
            const result = setItemProperty(formData.itemId, 'duration', parseInt(formData.duration));
            if (!result.success) {
                alert(result.error);
                return false;
            }
            return true;
        }
    },
    setUrgencyLimit: {
        fields: [
            {
                name: 'urgencyLevel',
                label: 'Urgency Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'limit',
                label: 'New Limit',
                type: 'number',
                required: true,
                placeholder: 'Enter limit (e.g., 30)',
                min: 0
            }
        ],
        handler: (formData) => {
            const result = setUrgencyLimit(parseInt(formData.urgencyLevel), parseInt(formData.limit));
            if (!result.success) {
                return false;
            }
            return true;
        }
    },
    setValueLimit: {
        fields: [
            {
                name: 'valueLevel',
                label: 'Value Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'limit',
                label: 'New Limit',
                type: 'number',
                required: true,
                placeholder: 'Enter limit (e.g., 30)',
                min: 0
            }
        ],
        handler: (formData) => {
            const result = setValueLimit(parseInt(formData.valueLevel), parseInt(formData.limit));
            if (!result.success) {
                return false;
            }
            return true;
        }
    },
    setUrgencyWeight: {
        fields: [
            {
                name: 'urgencyLevel',
                label: 'Urgency Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'weight',
                label: 'New Weight',
                type: 'number',
                required: true,
                placeholder: 'Enter weight (e.g., 1)',
                min: 0,
                step: 0.1
            }
        ],
        handler: (formData) => {
            const result = setUrgencyWeight(parseInt(formData.urgencyLevel), parseFloat(formData.weight));
            if (!result.success) {
                return false;
            }
            return true;
        }
    },
    setValueWeight: {
        fields: [
            {
                name: 'valueLevel',
                label: 'Value Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'weight',
                label: 'New Weight',
                type: 'number',
                required: true,
                placeholder: 'Enter weight (e.g., 1)',
                min: 0,
                step: 0.1
            }
        ],
        handler: (formData) => {
            const result = setValueWeight(parseInt(formData.valueLevel), parseFloat(formData.weight));
            if (!result.success) {
                return false;
            }
            return true;
        }
    },
    setDurationWeight: {
        fields: [
            {
                name: 'durationLevel',
                label: 'Duration Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'weight',
                label: 'New Weight',
                type: 'number',
                required: true,
                placeholder: 'Enter weight (e.g., 1)',
                min: 0,
                step: 0.1
            }
        ],
        handler: (formData) => {
            const result = setDurationWeight(parseInt(formData.durationLevel), parseFloat(formData.weight));
            if (!result.success) {
                return false;
            }
            return true;
        }
    },
    setUrgencyTitle: {
        fields: [
            {
                name: 'urgencyLevel',
                label: 'Urgency Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'title',
                label: 'New Title',
                type: 'text',
                required: true,
                placeholder: 'Enter title (e.g., WHENEVER)'
            }
        ],
        handler: (formData) => {
            const result = setUrgencyTitle(parseInt(formData.urgencyLevel), formData.title);
            if (!result.success) {
                return false;
            }
            return true;
        }
    },
    setUrgencyDescription: {
        fields: [
            {
                name: 'urgencyLevel',
                label: 'Urgency Level',
                type: 'select',
                required: true,
                options: () => [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' }
                ]
            },
            {
                name: 'description',
                label: 'New Description',
                type: 'textarea',
                required: true,
                placeholder: 'Enter description'
            }
        ],
        handler: (formData) => {
            const result = setUrgencyDescription(parseInt(formData.urgencyLevel), formData.description);
            if (!result.success) {
                return false;
            }
            return true;
        }
    }
};

// Step 2: Initialize default buckets structure using centralized defaults
function initializeBuckets() {
    // Deep clone the defaults to avoid mutation
    const buckets = {};
    for (const category of CATEGORIES) {
        buckets[category] = {};
        for (const level of LEVELS) {
            buckets[category][level] = { ...BUCKET_DEFAULTS[category][level] };
        }
    }
    return buckets;
}

// Step 3: Ensure buckets exist and are properly initialized
function ensureBuckets(appState) {
    if (!appState.buckets) {
        appState.buckets = initializeBuckets();
    }
    
    // Ensure each category exists with all levels
    for (const category of CATEGORIES) {
        if (!appState.buckets[category]) {
            appState.buckets[category] = {};
        }
        for (const level of LEVELS) {
            if (!appState.buckets[category][level]) {
                appState.buckets[category][level] = { ...BUCKET_DEFAULTS[category][level] };
            } else {
                // Merge with defaults to ensure all properties exist
                appState.buckets[category][level] = {
                    ...BUCKET_DEFAULTS[category][level],
                    ...appState.buckets[category][level]
                };
            }
        }
    }
    
    return appState;
}

// Step 6: Extract State Refresh Logic
function persistAndRefresh(appState, items = null) {
    if (items === null) {
        // Skip migration to avoid circular dependency - appState is already provided
        items = getItems(true);
    }
    updateBuckets(appState, items);
    saveAppState(appState);
    displayJson();
    return appState;
}

// Step 4: Unify All Bucket Update Functions
function updateBucketField(category, level, field, value, options = {}) {
    // Validate category and level
    if (!CATEGORIES.includes(category)) {
        return { success: false, error: `Invalid category: ${category}` };
    }
    if (!LEVELS.includes(level)) {
        return { success: false, error: `Invalid level: ${level}. Must be 1, 2, or 3.` };
    }
    
    // Validate field value using validators
    const validator = FIELD_VALIDATORS[field];
    if (!validator) {
        return { success: false, error: `Invalid field: ${field}` };
    }
    
    const validation = validator(value);
    if (!validation.valid) {
        alert(`Error: ${validation.error}`);
        return { success: false, error: validation.error };
    }
    
    // Get app state and ensure buckets exist
    const appState = getAppState();
    ensureBuckets(appState);
    
    // Update the field (use processed value if validator provided one)
    appState.buckets[category][level][field] = validation.processed !== undefined ? validation.processed : value;
    
    // If updating limit, we need to recalculate over-limits
    const needsRecalc = field === 'limit';
    
    // If updating weight, recalculate dependent values for all items
    let recalculatedItems = null;
    if (field === 'weight') {
        if (category === 'urgency' || category === 'value') {
            // Urgency/value weight change affects costOfDelay, which affects CD3
            recalculatedItems = recalculateAllCostOfDelay(appState);
        } else if (category === 'duration') {
            // Duration weight change only affects CD3
            recalculatedItems = recalculateAllCD3(appState);
        }
    }
    
    // Persist and refresh - use recalculated items if available, otherwise use items if limit changed
    persistAndRefresh(appState, recalculatedItems || (needsRecalc ? getItems() : null));
    
    // Force UI refresh after weight changes to ensure display is updated
    if (field === 'weight' && recalculatedItems) {
        displayData();
        displayJson();
    }
    
    console.log(`Set ${category} ${level} ${field} to:`, appState.buckets[category][level][field]);
    return { success: true };
}

// Step 9: Simplify Bucket Migration (replaces old migrateToBuckets)
function migrateToBuckets(state) {
    // If buckets already exists, return as-is
    if (state.buckets) {
        return state;
    }
    
    // Initialize buckets from centralized defaults
    state.buckets = initializeBuckets();
    
    // Migrate from old urgency_value_limits structure
    if (state.urgency_value_limits) {
        for (const category of ['urgency', 'value']) {
            if (state.urgency_value_limits[category]) {
                for (const level of LEVELS) {
                    if (state.urgency_value_limits[category][level] !== undefined) {
                        state.buckets[category][level].limit = state.urgency_value_limits[category][level];
                    }
                }
            }
        }
    }
    
    // Remove old properties
    delete state.urgency_value_limits;
    delete state.bucketOverLimits;
    
    // Ensure all buckets have defaults (ensureBuckets will handle this, but we do it here for migration)
    ensureBuckets(state);
    
    return state;
}

// Update buckets with current counts and over-limit status
function updateBuckets(state, items) {
    ensureBuckets(state);
    
    // Calculate counts
    const counts = calculateBucketCounts(items);
    
    // Update counts and over-limit status for each bucket
    for (const category of CATEGORIES) {
        for (const level of LEVELS) {
            state.buckets[category][level].count = counts[category][level] || 0;
            
            // Calculate over-limit (only for urgency and value, duration has no limits)
            if (category === 'urgency' || category === 'value') {
                const limit = state.buckets[category][level].limit;
                state.buckets[category][level].overLimit = (counts[category][level] || 0) > limit;
            } else {
                state.buckets[category][level].overLimit = false;
            }
        }
    }
    
    return state;
}

// Get app state
function getAppState() {
    const stored = localStorage.getItem(APP_STATE_KEY);
    let state;
    if (stored) {
        state = JSON.parse(stored);
        // Migrate entryStage to currentStage if needed (one-time migration)
        if (state.entryStage && !state.currentStage) {
            state.currentStage = state.entryStage;
            // Remove old entryStage after migration
            delete state.entryStage;
        }
        // Ensure currentStage is always "Item Listing" if not set or invalid
        // Also check if it's a valid stage in STAGE_ORDER
        if (!state.currentStage || state.currentStage === null || state.currentStage === undefined) {
            state.currentStage = 'Item Listing';
            saveAppState(state);
        } else if (!STAGE_ORDER.includes(state.currentStage)) {
            // Invalid stage value, reset to Item Listing
            state.currentStage = 'Item Listing';
            saveAppState(state);
        }
    } else {
        // Default state with buckets initialized and currentStage set to "Item Listing"
        state = { 
            currentStage: 'Item Listing',
            buckets: initializeBuckets(),
            locked: true // Default to locked (can only adjust current stage property)
        };
        // Save the default state
        saveAppState(state);
    }
    
    // Ensure locked property exists (default to true if not set)
    if (state.locked === undefined || state.locked === null) {
        state.locked = true;
        saveAppState(state);
    }
    
    // Migrate old structure if needed
    state = migrateToBuckets(state);
    
    // Ensure buckets are properly initialized
    ensureBuckets(state);
    
    // Always recalculate bucket counts and over-limits based on current items
    // Pass skipMigration=true to avoid circular dependency
    const items = getItems(true);
    state = updateBuckets(state, items);
    
    // Now that we have the state, migrate items that need costOfDelay/CD3/boardPosition/set flags calculation
    let itemsNeedSave = false;
    items.forEach(item => {
        if (item.costOfDelay === undefined || item.costOfDelay === null) {
            calculateCostOfDelay(item, state);
            itemsNeedSave = true;
        }
        if (item.CD3 === undefined || item.CD3 === null) {
            calculateCD3(item, state);
            itemsNeedSave = true;
        }
        if (!item.boardPosition) {
            calculateBoardPosition(item);
            itemsNeedSave = true;
        }
        // Migrate set flags: if property is > 0, it was set, so flag should be true
        if (item.urgencySet === undefined || item.urgencySet === null) {
            item.urgencySet = (item.urgency > 0);
            itemsNeedSave = true;
        }
        if (item.valueSet === undefined || item.valueSet === null) {
            item.valueSet = (item.value > 0);
            itemsNeedSave = true;
        }
        if (item.durationSet === undefined || item.durationSet === null) {
            item.durationSet = (item.duration > 0);
            itemsNeedSave = true;
        }
    });
    if (itemsNeedSave) {
        saveItems(items);
    }
    
    // Save updated state
    saveAppState(state);
    
    return state;
}

// Save app state
function saveAppState(state) {
    localStorage.setItem(APP_STATE_KEY, JSON.stringify(state));
}

// Set current stage (kept for backward compatibility, but use advanceStage/backStage instead)
function setEntryStage(stage) {
    return setCurrentStage(stage);
}

// Set current stage directly
function setCurrentStage(stage) {
    if (!STAGE_ORDER.includes(stage)) {
        return {
            success: false,
            error: `Invalid stage: ${stage}. Must be one of: ${STAGE_ORDER.join(', ')}`
        };
    }
    
    const items = getItems();
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    
    // Validate stage transitions when advancing forward (allow going backward without validation)
    // Also allow setting stage if there are no items (useful for test setup)
    if (STAGE_ORDER.indexOf(stage) > STAGE_ORDER.indexOf(currentStage) && items.length > 0) {
        const validation = STAGE_CONTROLLER.canAdvance(currentStage, items);
        if (!validation.canAdvance) {
            return {
                success: false,
                error: `Error: Cannot advance to ${stage.charAt(0).toUpperCase() + stage.slice(1)} stage. ${validation.reason}`
            };
        }
    }
    // Note: Going backward (e.g., from 'value' to 'urgency') is allowed without validation
    // Also, setting stage with no items is allowed (useful for test setup)
    
    STAGE_CONTROLLER.setCurrentStage(appState, stage);
    saveAppState(appState);
    displayJson();
    console.log('Current stage set to:', stage);
    return { success: true };
}

// Advance to next stage
function advanceStage() {
    const appState = getAppState();
    const items = getItems();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    
    const validation = STAGE_CONTROLLER.canAdvance(currentStage, items);
    if (!validation.canAdvance) {
        return {
            success: false,
            error: `Error: Cannot advance stage. ${validation.reason}`
        };
    }
    
    const nextStage = STAGE_CONTROLLER.getNextStage(currentStage);
    if (!nextStage) {
        return {
            success: false,
            error: 'Error: Already at the final stage (CD3). Cannot advance further.'
        };
    }
    
    STAGE_CONTROLLER.setCurrentStage(appState, nextStage);
    saveAppState(appState);
    displayJson();
    displayData(); // Update items display too
    updateStageButtonStates(); // Update button states after stage change
    updateLockedDisplay(); // Update locked display (description may change based on stage)
    console.log('Advanced to stage:', nextStage);
    return { success: true };
}

// Go back to previous stage
function backStage() {
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    
    if (!STAGE_CONTROLLER.canGoBack(currentStage)) {
        return {
            success: false,
            error: 'Error: Already at the first stage (Urgency). Cannot go back further.'
        };
    }
    
    const previousStage = STAGE_CONTROLLER.getPreviousStage(currentStage);
    STAGE_CONTROLLER.setCurrentStage(appState, previousStage);
    saveAppState(appState);
    displayJson();
    displayData(); // Update items display too
    updateStageButtonStates(); // Update button states after stage change
    updateLockedDisplay(); // Update locked display (description may change based on stage)
    console.log('Went back to stage:', previousStage);
    return { success: true };
}

// Step 4: Unified bucket update functions (replaces all individual setters)
function setUrgencyLimit(level, limit) {
    return updateBucketField('urgency', level, 'limit', limit);
}

function setValueLimit(level, limit) {
    return updateBucketField('value', level, 'limit', limit);
}

function setUrgencyWeight(level, weight) {
    return updateBucketField('urgency', level, 'weight', weight);
}

function setValueWeight(level, weight) {
    return updateBucketField('value', level, 'weight', weight);
}

function setDurationWeight(level, weight) {
    return updateBucketField('duration', level, 'weight', weight);
}

function setUrgencyTitle(level, title) {
    return updateBucketField('urgency', level, 'title', title);
}

function setUrgencyDescription(level, description) {
    return updateBucketField('urgency', level, 'description', description);
}

function setValueTitle(level, title) {
    return updateBucketField('value', level, 'title', title);
}

function setValueDescription(level, description) {
    return updateBucketField('value', level, 'description', description);
}

function setDurationTitle(level, title) {
    return updateBucketField('duration', level, 'title', title);
}

function setDurationDescription(level, description) {
    return updateBucketField('duration', level, 'description', description);
}

// Start App - clears data and initializes fresh state
// Note: Test data loading and test execution are handled externally through the API
function startApp() {
    // Clear items storage
    localStorage.removeItem(STORAGE_KEY);
    // Clear app state to ensure fresh start
    localStorage.removeItem(APP_STATE_KEY);
    
    // Initialize app state with current stage and buckets
    const appState = {
        currentStage: 'Item Listing',
        buckets: initializeBuckets(),
        locked: true // Default to locked
    };
    saveAppState(appState);
    
    // Force update display and ensure stage is preserved
    displayData();
    displayJson();
    updateStageButtonStates();
    updateCurrentStageDisplay();
    
    // Double-check that stage is still Item Listing after all updates
    const finalState = getAppState();
    if (finalState.currentStage !== 'Item Listing') {
        finalState.currentStage = 'Item Listing';
        saveAppState(finalState);
        displayJson();
        updateCurrentStageDisplay();
    }
    
    console.log('App started - ready to add items at Item Listing stage');
    return { success: true };
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
    const commandSelect = document.getElementById('commandSelect');
    const clearBtn = document.getElementById('clearBtn');
    const runTestsBtn = document.getElementById('runTestsBtn');
    const startAppBtn = document.getElementById('startAppBtn');
    const advanceStageBtn = document.getElementById('advanceStageBtn');
    const backStageBtn = document.getElementById('backStageBtn');
    const addItemBtn = document.getElementById('addItemBtn');
    
    // Add Item button (only visible in Item Listing stage)
    if (addItemBtn) {
        addItemBtn.addEventListener('click', () => {
            const itemName = prompt('Enter item name:');
            if (itemName && itemName.trim() !== '') {
                const result = addItem(itemName.trim());
                if (!result.success) {
                    alert(result.error);
                }
            }
        });
    }
    
    // Toggle Locked button
    const toggleLockedBtn = document.getElementById('toggleLockedBtn');
    if (toggleLockedBtn) {
        toggleLockedBtn.addEventListener('click', () => {
            const appState = getAppState();
            appState.locked = !appState.locked;
            saveAppState(appState);
            updateLockedDisplay();
            displayData(); // Refresh item display to update button states
            displayJson();
        });
    }
    
    // Advance Stage button
    if (advanceStageBtn) {
        advanceStageBtn.addEventListener('click', () => {
            const result = advanceStage();
            if (!result.success) {
                alert(result.error);
            }
        });
    }
    
    // Back Stage button
    if (backStageBtn) {
        backStageBtn.addEventListener('click', () => {
            const result = backStage();
            if (!result.success) {
                alert(result.error);
            }
        });
    }
    // Show form when command is selected
    commandSelect.addEventListener('change', (e) => {
        const command = e.target.value;
        if (command) {
            showForm(command);
        } else {
            hideForm();
        }
    });

    // Clear all data
    clearBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to clear all data?')) {
            clearAllData();
        }
    });

    // Start App button
    if (startAppBtn) {
        startAppBtn.addEventListener('click', () => {
            if (confirm('Start App will clear all data, load initial items, and run tests. Continue?')) {
                startApp();
            }
        });
    }

    // Run all tests - tests are decoupled, so we just call the exposed function
    if (runTestsBtn) {
        runTestsBtn.addEventListener('click', () => {
            // Tests are completely decoupled - they expose their own runAllTests function
            if (typeof window.runAllTests === 'function') {
                try {
                    window.runAllTests();
                } catch (error) {
                    console.error('Test error:', error);
                    alert('Error running tests: ' + error.message);
                }
            } else {
                alert('Test suite not loaded. Please check the browser console (F12) for JavaScript errors.');
            }
        });
    }

    // Ensure current stage is set to "Item Listing" on app start
    // Always reset to Item Listing on initial page load, regardless of stored state
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    if (currentStage !== 'Item Listing') {
        // Force reset to Item Listing on app start
        appState.currentStage = 'Item Listing';
        saveAppState(appState);
    }
    
    // Update current stage display, locked display, and button states on page load
    updateCurrentStageDisplay();
    updateLockedDisplay();
    updateStageButtonStates();
    
    // Copy failing tests button
    const copyFailingTestsBtn = document.getElementById('copyFailingTestsBtn');
    if (copyFailingTestsBtn) {
        copyFailingTestsBtn.addEventListener('click', () => {
            if (typeof window.copyFailingTests === 'function') {
                window.copyFailingTests();
            } else {
                alert('Copy failing tests function not available. Please run tests first.');
            }
        });
    }

    // Display initial data
    displayData();
    displayJson();
});

// Step 8: Extract Field Renderers
function renderFormField(field) {
    const label = `<label for="${field.name}">${field.label}${field.required ? ' *' : ''}</label>`;
    const requiredAttr = field.required ? 'required' : '';
    
    if (field.type === 'select') {
        const options = typeof field.options === 'function' ? field.options() : field.options || [];
        return `
            <div class="form-field">
                ${label}
                <select id="${field.name}" name="${field.name}" ${requiredAttr}>
                    <option value="">Select ${field.label.toLowerCase()}...</option>
                    ${options.map(opt => `<option value="${escapeHtml(opt.value)}">${escapeHtml(opt.label)}</option>`).join('')}
                </select>
            </div>
        `;
    } else if (field.type === 'textarea') {
        return `
            <div class="form-field">
                ${label}
                <textarea 
                    id="${field.name}" 
                    name="${field.name}"
                    placeholder="${field.placeholder || ''}"
                    ${requiredAttr}
                    rows="4"
                    style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit;"
                ></textarea>
            </div>
        `;
    } else {
        const attrs = [
            requiredAttr,
            field.min !== undefined ? `min="${field.min}"` : '',
            field.max !== undefined ? `max="${field.max}"` : '',
            field.step !== undefined ? `step="${field.step}"` : ''
        ].filter(Boolean).join(' ');
        
        return `
            <div class="form-field">
                ${label}
                <input 
                    type="${field.type}" 
                    id="${field.name}" 
                    name="${field.name}"
                    placeholder="${field.placeholder || ''}"
                    ${attrs}
                />
            </div>
        `;
    }
}

// Step 7 & 8: Refactored showForm with extracted renderers
function showForm(command) {
    const formConfig = COMMAND_FORMS[command];
    if (!formConfig) return;

    const formContainer = document.getElementById('dynamicForm');
    
    // Handle commands with no fields (like startApp)
    if (!formConfig.fields || formConfig.fields.length === 0) {
        formContainer.style.display = 'block';
        formContainer.innerHTML = `
            <form id="commandForm">
                <div class="form-info">This command will execute immediately when you click "Go".</div>
                <button type="submit" class="submit-btn">Go</button>
            </form>
        `;
        
        // Handle form submission
        const form = document.getElementById('commandForm');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const result = formConfig.handler({});
            if (result !== false) {
                hideForm();
                document.getElementById('commandSelect').value = '';
            }
        });
        return;
    }

    formContainer.style.display = 'block';

    // Check if command requires items and there are none
    // Commands that don't require items: addItem, bulkAddItems, setUrgencyLimit, setValueLimit, setUrgencyWeight, setValueWeight, setDurationWeight, setUrgencyTitle, setUrgencyDescription, setValueTitle, setValueDescription, setDurationTitle, setDurationDescription, startApp, advanceStage, backStage
    const commandsWithoutItems = ['addItem', 'bulkAddItems', 'setUrgencyLimit', 'setValueLimit', 'setUrgencyWeight', 'setValueWeight', 'setDurationWeight', 'setUrgencyTitle', 'setUrgencyDescription', 'setValueTitle', 'setValueDescription', 'setDurationTitle', 'setDurationDescription', 'startApp', 'advanceStage', 'backStage'];
    const items = getItems();
    const requiresItems = !commandsWithoutItems.includes(command);
    if (requiresItems && items.length === 0) {
        formContainer.innerHTML = '<div class="empty-state">No items available. Please add an item first.</div>';
        return;
    }

    // Build form HTML using field renderers
    const fieldsHTML = formConfig.fields.map(field => renderFormField(field)).join('');
    formContainer.innerHTML = `
        <form id="commandForm">
            ${fieldsHTML}
            <button type="submit" class="submit-btn">Go</button>
        </form>
    `;

    // Handle form submission
    const form = document.getElementById('commandForm');
    form.addEventListener('submit', (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const data = {};
        formData.forEach((value, key) => {
            data[key] = value;
        });
        
        // For textarea fields, get the value directly (FormData handles it, but we want to preserve newlines)
        formConfig.fields.forEach(field => {
            if (field.type === 'textarea') {
                const textarea = form.querySelector(`[name="${field.name}"]`);
                if (textarea) {
                    data[field.name] = textarea.value;
                }
            }
        });
        
        // Execute command handler
        const result = formConfig.handler(data);
        
        // Only reset form if handler succeeded (returns true or undefined)
        if (result !== false) {
            // Reset form and hide it
            form.reset();
            hideForm();
            document.getElementById('commandSelect').value = '';
        }
    });
}

// Hide dynamic form
function hideForm() {
    const formContainer = document.getElementById('dynamicForm');
    formContainer.style.display = 'none';
    formContainer.innerHTML = '';
}

// Add an item to the priority list
function addItem(name) {
    // Check current stage - can only add items when current stage is "Item Listing"
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    
    if (currentStage !== 'Item Listing') {
        return {
            success: false,
            error: `Error: Cannot add item. Current stage is "${currentStage}". You must be on the "Item Listing" stage to add new items. Use "Back Stage" command to return to Item Listing stage.`
        };
    }
    
    const items = getItems();
    
    const newItem = {
        id: Date.now().toString(),
        name: name,
        urgency: 0,
        value: 0,
        duration: 0,
        urgencySet: false,
        valueSet: false,
        durationSet: false,
        costOfDelay: 0,
        CD3: 0,
        active: true,
        createdAt: new Date().toISOString()
    };
    
    // Calculate initial board position
    calculateBoardPosition(newItem);

    items.push(newItem);
    saveItems(items);
    
    // Update buckets and refresh UI
    const appStateAfter = getAppState();
    persistAndRefresh(appStateAfter, items);
    displayData();
    updateStageButtonStates(); // Update button states in case items changed affects navigation
    
    console.log('Added item:', newItem);
    return { success: true };
}

// Bulk add items from a newline-separated list
function bulkAddItems(itemNamesText) {
    // Check current stage - can only add items when current stage is "Item Listing"
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    
    if (currentStage !== 'Item Listing') {
        return {
            success: false,
            error: `Error: Cannot bulk add items. Current stage is "${currentStage}". You must be on the "Item Listing" stage to add new items. Use "Back Stage" command to return to Item Listing stage.`
        };
    }
    
    if (!itemNamesText || typeof itemNamesText !== 'string') {
        return {
            success: false,
            error: 'Error: Invalid input. Please provide item names separated by newlines.'
        };
    }
    
    // Split by newlines and filter out empty lines
    const itemNames = itemNamesText
        .split('\n')
        .map(name => name.trim())
        .filter(name => name.length > 0);
    
    if (itemNames.length === 0) {
        return {
            success: false,
            error: 'Error: No valid item names found. Please enter at least one item name.'
        };
    }
    
    const items = getItems();
    const errors = [];
    let added = 0;
    
    // Add each item directly (bypassing addItem's stage check since we already checked)
    itemNames.forEach((name, index) => {
        // Create item directly to avoid duplicate stage checks
        const newItem = {
            id: (Date.now() + index).toString(), // Ensure unique IDs
            name: name,
            urgency: 0,
            value: 0,
            duration: 0,
            urgencySet: false,
            valueSet: false,
            durationSet: false,
            costOfDelay: 0,
            CD3: 0,
            active: true,
            createdAt: new Date().toISOString()
        };
        
        // Calculate initial board position
        calculateBoardPosition(newItem);
        
        items.push(newItem);
        added++;
    });
    
    // Save all items at once
    saveItems(items);
    
    // Update buckets and refresh UI
    const appStateAfter = getAppState();
    persistAndRefresh(appStateAfter, items);
    displayData();
    updateStageButtonStates();
    
    console.log(`Bulk added ${added} item(s)`);
    return {
        success: true,
        added: added,
        total: itemNames.length,
        errors: errors
    };
}

// Set a property on an item (refactored to use PROPERTY_META)
function setItemProperty(itemId, property, value) {
    const items = getItems();
    const item = items.find(i => i.id === itemId);
    
    if (!item) {
        return { success: false, error: 'Item not found' };
    }
    
    // Get property metadata
    const meta = PROPERTY_META[property];
    if (!meta) {
        return { success: false, error: `Invalid property: ${property}` };
    }
    
    // Check current stage - can only set the property that matches the current stage (unless unlocked)
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    const isLocked = appState.locked !== false; // Default to true if not set
    
    // If locked, can only set property matching current stage
    // If unlocked, can set property matching current stage OR any previous stage
    if (isLocked) {
        if (currentStage !== meta.stage) {
            return { 
                success: false, 
                error: `Error: Cannot set ${property.charAt(0).toUpperCase() + property.slice(1)}. Current stage is "${currentStage}". You must be on the "${meta.stage}" stage to set ${property} values. Use "Advance Stage" or "Back Stage" commands to navigate.` 
            };
        }
    } else {
        // Unlocked: can set current stage property OR previous stage properties
        const currentStageIndex = STAGE_ORDER.indexOf(currentStage);
        const propertyStageIndex = STAGE_ORDER.indexOf(meta.stage);
        
        // Can set if it's the current stage OR a previous stage
        if (propertyStageIndex > currentStageIndex) {
            return { 
                success: false, 
                error: `Error: Cannot set ${property.charAt(0).toUpperCase() + property.slice(1)}. Current stage is "${currentStage}". You must be on the "${meta.stage}" stage or later to set ${property} values. Use "Advance Stage" command to navigate.` 
            };
        }
    }
    
    // Validate prerequisites using explicit set flags
    for (const prereq of meta.prerequisites) {
        const prereqSetFlag = prereq + 'Set'; // e.g., 'urgencySet', 'valueSet'
        if (!item[prereqSetFlag]) {
            return { 
                success: false, 
                error: `Error: Cannot set ${property.charAt(0).toUpperCase() + property.slice(1)}. Item must have ${prereq.charAt(0).toUpperCase() + prereq.slice(1)} set first. Please set ${prereq.charAt(0).toUpperCase() + prereq.slice(1)} (1-3) before setting ${property.charAt(0).toUpperCase() + property.slice(1)}.` 
            };
        }
    }
    
    // Prevent setting urgency, value, or duration back to 0 once they've been set
    // Check the explicit set flag instead of checking if value > 0
    if (property === 'urgency' || property === 'value' || property === 'duration') {
        const setFlag = property + 'Set'; // e.g., 'urgencySet', 'valueSet', 'durationSet'
        
        // If trying to set to 0 and the property has been set before, prevent it
        if (value === 0 && item[setFlag]) {
            return {
                success: false,
                error: `Error: Cannot unset ${property.charAt(0).toUpperCase() + property.slice(1)}. Once ${property.charAt(0).toUpperCase() + property.slice(1)} has been set, it cannot be changed back to 0. You can change it to a different value (1-3), but not unset it.`
            };
        }
        
        // If setting to a non-zero value for the first time, mark as set
        if (value > 0 && !item[setFlag]) {
            item[setFlag] = true;
        }
    }
    
    // Set the property (no hard validation - we track over-limits instead)
    item[property] = value;
    
    // Recalculate dependent values based on what changed
    // Always get fresh appState to ensure we have latest weights
    const currentAppState = getAppState();
    ensureBuckets(currentAppState);
    
    if (property === 'urgency' || property === 'value') {
        // Urgency or value change affects costOfDelay, which affects CD3
        calculateCostOfDelay(item, currentAppState);
    } else if (property === 'duration') {
        // Duration change only affects CD3 (costOfDelay doesn't change)
        calculateCD3(item, currentAppState);
    }
    
    // Update board position whenever urgency, value, or duration changes
    if (property === 'urgency' || property === 'value' || property === 'duration') {
        calculateBoardPosition(item);
    }
    
    saveItems(items);
    
    // Update buckets and refresh UI
    persistAndRefresh(currentAppState, items);
    displayData();
    updateStageButtonStates(); // Update button states in case items changed affects navigation
    updateLockedDisplay(); // Update locked display in case it changed
    
    console.log(`Set ${property} for item ${item.name}:`, value);
    return { success: true };
}

// Set item active status
function setItemActive(itemId) {
    const items = getItems();
    const item = items.find(i => i.id === itemId);
    
    if (!item) {
        return { success: false, error: 'Item not found' };
    }
    
    item.active = true;
    saveItems(items);
    
    // Update buckets and refresh UI
    const appState = getAppState();
    persistAndRefresh(appState, items);
    displayData();
    displayJson();
    
    console.log(`Set item ${item.name} to active`);
    return { success: true };
}

// Set item inactive status
function setItemInactive(itemId) {
    const items = getItems();
    const item = items.find(i => i.id === itemId);
    
    if (!item) {
        return { success: false, error: 'Item not found' };
    }
    
    item.active = false;
    saveItems(items);
    
    // Update buckets and refresh UI
    const appState = getAppState();
    persistAndRefresh(appState, items);
    displayData();
    displayJson();
    
    console.log(`Set item ${item.name} to inactive`);
    return { success: true };
}

// Calculate board position based on urgency, value, and duration
// Rules:
// - If urgency=0, value=0, duration=0: row=0, col=0, duration=null
// - If urgency>0, value=0, duration=0: row=0, col=urgency, duration=null
// - If value>0: row=value, col=urgency, duration=duration (or null if duration=0)
function calculateBoardPosition(item) {
    const urgency = item.urgency || 0;
    const value = item.value || 0;
    const duration = item.duration || 0;
    
    let row, col, durationBucket;
    
    // If no urgency, value, or duration: Row 0, Col 0
    if (urgency === 0 && value === 0 && duration === 0) {
        row = 0;
        col = 0;
        durationBucket = null;
    }
    // If urgency is set but value is not: Row 0, Col = urgency
    else if (urgency > 0 && value === 0) {
        row = 0;
        col = urgency;
        durationBucket = null;
    }
    // If value is set: Row = value, Col = urgency
    else if (value > 0) {
        row = value;
        col = urgency || 0; // If urgency is 0 but value is set, col should be 0
        durationBucket = duration > 0 ? duration : null;
    }
    // Fallback (shouldn't happen, but handle edge cases)
    else {
        row = 0;
        col = 0;
        durationBucket = null;
    }
    
    // Update the item's boardPosition property
    item.boardPosition = {
        row: row,
        col: col,
        duration: durationBucket
    };
    
    return item.boardPosition;
}

// Calculate cost of delay for an item
// costOfDelay = urgency_weight  value_weight
// Only calculated when both urgency and value are set (not 0)
// appState parameter is optional - if provided, uses that instead of fetching from storage
function calculateCostOfDelay(item, appState = null) {
    if (!appState) {
        appState = getAppState();
    }
    ensureBuckets(appState);
    
    // If either urgency or value is not set (0), cost of delay is 0
    if (!item.urgency || item.urgency === 0 || !item.value || item.value === 0) {
        item.costOfDelay = 0;
        // Also recalculate CD3 since cost of delay changed
        calculateCD3(item, appState);
        return;
    }
    
    // Get weights from buckets
    const urgencyWeight = appState.buckets.urgency[item.urgency]?.weight || 1;
    const valueWeight = appState.buckets.value[item.value]?.weight || 1;
    
    // Calculate cost of delay
    item.costOfDelay = urgencyWeight * valueWeight;
    
    // Also recalculate CD3 since cost of delay changed
    calculateCD3(item, appState);
}

// Calculate CD3 for an item
// CD3 = costOfDelay / duration_weight
// Only calculated when duration is set (not 0)
// appState parameter is optional - if provided, uses that instead of fetching from storage
function calculateCD3(item, appState = null) {
    if (!appState) {
        appState = getAppState();
    }
    ensureBuckets(appState);
    
    // If duration is not set (0), CD3 is 0
    if (!item.duration || item.duration === 0) {
        item.CD3 = 0;
        return;
    }
    
    // If cost of delay is 0, CD3 is 0
    if (!item.costOfDelay || item.costOfDelay === 0) {
        item.CD3 = 0;
        return;
    }
    
    // Get duration weight from buckets
    const durationWeight = appState.buckets.duration[item.duration]?.weight || 1;
    
    // Calculate CD3: cost of delay divided by duration weight
    item.CD3 = item.costOfDelay / durationWeight;
}

// Recalculate cost of delay for all items (used when urgency/value weights change)
// appState parameter is optional - if provided, uses that instead of fetching from storage
function recalculateAllCostOfDelay(appState = null) {
    if (!appState) {
        appState = getAppState();
    }
    ensureBuckets(appState);
    const items = getItems();
    items.forEach(item => {
        calculateCostOfDelay(item, appState);
        // CD3 is recalculated by calculateCostOfDelay
    });
    saveItems(items);
    return items; // Return updated items
}

// Recalculate CD3 for all items (used when duration weights change)
// appState parameter is optional - if provided, uses that instead of fetching from storage
function recalculateAllCD3(appState = null) {
    if (!appState) {
        appState = getAppState();
    }
    ensureBuckets(appState);
    const items = getItems();
    items.forEach(item => {
        calculateCD3(item, appState);
    });
    saveItems(items);
    return items; // Return updated items
}

// Get all items from local storage
// skipMigration: if true, skips migration checks to avoid circular dependencies
function getItems(skipMigration = false) {
    const stored = localStorage.getItem(STORAGE_KEY);
    const items = stored ? JSON.parse(stored) : [];
    
    // Ensure all items have costOfDelay, CD3, active, and boardPosition properties (migration for existing items)
    // Skip migration if we're being called from getAppState() to avoid circular dependency
    if (!skipMigration) {
        let needsSave = false;
        // Only migrate active, boardPosition, and set flags properties here (no appState needed)
        items.forEach(item => {
            if (item.active === undefined || item.active === null) {
                item.active = true; // Default to active
                needsSave = true;
            }
            if (!item.boardPosition) {
                calculateBoardPosition(item);
                needsSave = true;
            }
            // Migrate set flags: if property is > 0, it was set, so flag should be true
            if (item.urgencySet === undefined || item.urgencySet === null) {
                item.urgencySet = (item.urgency > 0);
                needsSave = true;
            }
            if (item.valueSet === undefined || item.valueSet === null) {
                item.valueSet = (item.value > 0);
                needsSave = true;
            }
            if (item.durationSet === undefined || item.durationSet === null) {
                item.durationSet = (item.duration > 0);
                needsSave = true;
            }
        });
        
        // For costOfDelay and CD3, we'll calculate them later when appState is available
        // This avoids the circular dependency with getAppState()
        if (needsSave) {
            saveItems(items);
        }
    }
    
    return items;
}

// Save items to local storage
function saveItems(items) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
}

// Display all items
function displayData() {
    const items = getItems();
    const displayDiv = document.getElementById('dataDisplay');
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);

    if (items.length === 0) {
        displayDiv.innerHTML = '<div class="empty-state">No items yet. Click "Add Item" button to add items.</div>';
        return;
    }

    displayDiv.innerHTML = items.map(item => {
        const urgency = item.urgency || 0;
        const value = item.value || 0;
        const duration = item.duration || 0;
        
        // Determine which buttons should be enabled based on current stage, prerequisites, and locked setting
        const isLocked = appState.locked !== false; // Default to true if not set
        
        let canSetUrgency, canSetValue, canSetDuration;
        
        if (isLocked) {
            // Locked: can only set property matching current stage
            canSetUrgency = currentStage === 'urgency';
            canSetValue = currentStage === 'value' && item.urgencySet;
            canSetDuration = currentStage === 'duration' && item.valueSet;
        } else {
            // Unlocked: can set current stage property OR previous stage properties
            const currentStageIndex = STAGE_ORDER.indexOf(currentStage);
            const urgencyStageIndex = STAGE_ORDER.indexOf('urgency');
            const valueStageIndex = STAGE_ORDER.indexOf('value');
            const durationStageIndex = STAGE_ORDER.indexOf('duration');
            
            // Can set urgency if we're at urgency stage or later
            canSetUrgency = urgencyStageIndex <= currentStageIndex;
            
            // Can set value if we're at value stage or later, and urgency is set
            canSetValue = valueStageIndex <= currentStageIndex && item.urgencySet;
            
            // Can set duration if we're at duration stage or later, and value is set
            canSetDuration = durationStageIndex <= currentStageIndex && item.valueSet;
        }
        
        // Helper function to create increment/decrement buttons
        const createPropertyButtons = (property, currentValue, canSet) => {
            const canIncrement = canSet && currentValue < 3;
            // Can only decrement if value is > 1 (cannot unset once set)
            const canDecrement = canSet && currentValue > 1;
            const displayValue = currentValue > 0 ? currentValue : '';
            
            return `
                <div class="property-control">
                    <span class="property-label">${property.charAt(0).toUpperCase() + property.slice(1)}:</span>
                    <span class="property-value">${displayValue}</span>
                    <div class="property-buttons">
                        <button class="property-btn decrement-btn" 
                                data-item-id="${item.id}" 
                                data-property="${property}" 
                                data-action="decrement"
                                ${!canDecrement ? 'disabled' : ''}
                                title="${!canSet ? `Must be on ${property} stage` : !canDecrement ? (currentValue === 0 ? 'Not set yet' : 'Cannot unset once set (minimum is 1)') : `Decrease ${property}`}"></button>
                        <button class="property-btn increment-btn" 
                                data-item-id="${item.id}" 
                                data-property="${property}" 
                                data-action="increment"
                                ${!canIncrement ? 'disabled' : ''}
                                title="${!canSet ? `Must be on ${property} stage` : !canIncrement ? 'Already at maximum (3)' : `Increase ${property}`}">+</button>
                    </div>
                </div>
            `;
        };
        
        // Get costOfDelay and CD3 for display
        const costOfDelay = item.costOfDelay || 0;
        const CD3 = item.CD3 || 0;
        const isActive = item.active !== false; // Default to true
        
        return `
        <div class="item ${!isActive ? 'item-inactive' : ''}" data-item-id="${item.id}">
            <span class="item-status" title="${isActive ? 'Active' : 'Inactive'}">
                ${isActive ? '' : ''}
            </span>
            <span class="item-name">${escapeHtml(item.name)}</span>
            ${createPropertyButtons('urgency', urgency, canSetUrgency)}
            ${createPropertyButtons('value', value, canSetValue)}
            ${createPropertyButtons('duration', duration, canSetDuration)}
            <span class="item-metric">CoD: <strong>${costOfDelay}</strong></span>
            <span class="item-metric">CD3: <strong>${CD3.toFixed(2)}</strong></span>
            <button class="toggle-active-btn" 
                    data-item-id="${item.id}" 
                    data-action="${isActive ? 'inactive' : 'active'}"
                    title="${isActive ? 'Set inactive' : 'Set active'}">
                ${isActive ? 'Deactivate' : 'Activate'}
            </button>
        </div>
        `;
    }).join('');
    
    // Attach event listeners to all property buttons
    attachPropertyButtonListeners();
    
    // Attach event listeners to toggle active buttons
    attachToggleActiveListeners();
}

// Attach event listeners to property increment/decrement buttons
function attachPropertyButtonListeners() {
    const buttons = document.querySelectorAll('.property-btn');
    buttons.forEach(button => {
        // Remove existing listeners by cloning
        const newButton = button.cloneNode(true);
        button.parentNode.replaceChild(newButton, button);
        
        // Add new listener
        newButton.addEventListener('click', (e) => {
            const itemId = newButton.getAttribute('data-item-id');
            const property = newButton.getAttribute('data-property');
            const action = newButton.getAttribute('data-action');
            
            const items = getItems();
            const item = items.find(i => i.id === itemId);
            if (!item) {
                alert('Item not found');
                return;
            }
            
            const currentValue = item[property] || 0;
            let newValue;
            
            if (action === 'increment') {
                newValue = Math.min(3, currentValue + 1);
            } else if (action === 'decrement') {
                // Cannot decrement below 1 (cannot unset once set)
                newValue = Math.max(1, currentValue - 1);
            } else {
                return;
            }
            
            // Use setItemProperty which handles all validation
            const result = setItemProperty(itemId, property, newValue);
            if (!result.success) {
                alert(result.error);
            }
            // displayData() is already called by setItemProperty, so UI will update automatically
        });
    });
}

// Attach event listeners to toggle active/inactive buttons
function attachToggleActiveListeners() {
    const buttons = document.querySelectorAll('.toggle-active-btn');
    buttons.forEach(button => {
        // Remove existing listeners by cloning
        const newButton = button.cloneNode(true);
        button.parentNode.replaceChild(newButton, button);
        
        // Add new listener
        newButton.addEventListener('click', (e) => {
            const itemId = newButton.getAttribute('data-item-id');
            const action = newButton.getAttribute('data-action');
            
            if (action === 'active') {
                const result = setItemActive(itemId);
                if (!result.success) {
                    alert(result.error);
                }
            } else {
                const result = setItemInactive(itemId);
                if (!result.success) {
                    alert(result.error);
                }
            }
        });
    });
}

// Calculate bucket counts from items (refactored to use constants)
function calculateBucketCounts(items) {
    const counts = {};
    for (const category of CATEGORIES) {
        counts[category] = {};
        for (const level of LEVELS) {
            counts[category][level] = 0;
        }
    }
    
    items.forEach(item => {
        for (const category of CATEGORIES) {
            const value = item[category];
            if (value && value > 0 && LEVELS.includes(value)) {
                counts[category][value] = (counts[category][value] || 0) + 1;
            }
        }
    });
    
    return counts;
}


// Display JSON data
function displayJson() {
    const items = getItems();
    const appState = getAppState();
    const jsonDisplay = document.getElementById('jsonDisplay');
    
    const jsonData = {
        currentStage: STAGE_CONTROLLER.getCurrentStage(appState),
        locked: appState.locked !== false, // Show true/false explicitly
        buckets: appState.buckets || initializeBuckets(),
        items: items
    };
    
    jsonDisplay.textContent = JSON.stringify(jsonData, null, 2);
    
    // Update current stage display
    updateCurrentStageDisplay();
}

// Update current stage display
function updateCurrentStageDisplay() {
    const appState = getAppState();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    const currentStageText = document.getElementById('currentStageText');
    if (currentStageText) {
        // Capitalize first letter
        const displayStage = currentStage.charAt(0).toUpperCase() + currentStage.slice(1);
        currentStageText.textContent = displayStage;
    }
}

// Update locked setting display
function updateLockedDisplay() {
    const appState = getAppState();
    const isLocked = appState.locked !== false; // Default to true
    const lockedStatusText = document.getElementById('lockedStatusText');
    const lockedDescriptionText = document.getElementById('lockedDescriptionText');
    
    if (lockedStatusText) {
        lockedStatusText.textContent = isLocked ? 'ON' : 'OFF';
        lockedStatusText.style.color = isLocked ? '#dc3545' : '#28a745';
        lockedStatusText.style.fontWeight = 'bold';
    }
    
    if (lockedDescriptionText) {
        const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
        if (isLocked) {
            lockedDescriptionText.textContent = `Can only adjust ${currentStage} values in ${currentStage} stage`;
        } else {
            if (currentStage === 'value') {
                lockedDescriptionText.textContent = 'Can adjust urgency and value in value stage';
            } else if (currentStage === 'duration') {
                lockedDescriptionText.textContent = 'Can adjust urgency, value, and duration in duration stage';
            } else {
                lockedDescriptionText.textContent = 'Can adjust all previous stage properties';
            }
        }
    }
}

// Update stage navigation button states
function updateStageButtonStates() {
    const appState = getAppState();
    const items = getItems();
    const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
    const buttonStates = STAGE_CONTROLLER.getButtonStates(currentStage, items);
    
    const advanceBtn = document.getElementById('advanceStageBtn');
    const backBtn = document.getElementById('backStageBtn');
    const addItemBtnContainer = document.getElementById('addItemButtonContainer');
    
    if (advanceBtn) {
        advanceBtn.disabled = !buttonStates.canAdvance;
        advanceBtn.title = buttonStates.advanceReason || 'Advance to next stage';
    }
    
    if (backBtn) {
        backBtn.disabled = !buttonStates.canGoBack;
        backBtn.title = buttonStates.backReason || 'Go back to previous stage';
    }
    
    // Show/hide Add Item button based on current stage
    if (addItemBtnContainer) {
        if (currentStage === 'Item Listing') {
            addItemBtnContainer.style.display = 'block';
        } else {
            addItemBtnContainer.style.display = 'none';
        }
    }
}

// Clear all data
function clearAllData() {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(APP_STATE_KEY);
    displayData();
    // Reset JSON display to show empty state
    const jsonDisplay = document.getElementById('jsonDisplay');
    jsonDisplay.textContent = JSON.stringify({
        currentStage: 'Item Listing',
        buckets: initializeBuckets(),
        items: []
    }, null, 2);
    console.log('All data cleared');
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Expose app instance to API (decoupled interface)
// The API will handle all external access, including tests
if (typeof window !== 'undefined' && window.PriorityManagerAPI) {
    window.PriorityManagerAPI.init({
        getItems: getItems,
        addItem: addItem,
        bulkAddItems: bulkAddItems,
        setItemProperty: setItemProperty,
        getCurrentStage: function() {
            const appState = getAppState();
            return STAGE_CONTROLLER.getCurrentStage(appState);
        },
        advanceStage: advanceStage,
        backStage: backStage,
        setCurrentStage: setCurrentStage,
        setUrgencyLimit: setUrgencyLimit,
        setValueLimit: setValueLimit,
        setUrgencyWeight: setUrgencyWeight,
        setValueWeight: setValueWeight,
        setDurationWeight: setDurationWeight,
        setItemActive: setItemActive,
        setItemInactive: setItemInactive,
        setUrgencyTitle: setUrgencyTitle,
        setUrgencyDescription: setUrgencyDescription,
        setValueTitle: setValueTitle,
        setValueDescription: setValueDescription,
        setDurationTitle: setDurationTitle,
        setDurationDescription: setDurationDescription,
        getAppState: getAppState,
        clearAllData: clearAllData,
        startApp: startApp,
        getButtonStates: function() {
            const appState = getAppState();
            const items = getItems();
            const currentStage = STAGE_CONTROLLER.getCurrentStage(appState);
            return STAGE_CONTROLLER.getButtonStates(currentStage, items);
        },
        
        updateStageButtonStates: updateStageButtonStates,
        setLocked: function(locked) {
            const appState = getAppState();
            appState.locked = locked;
            saveAppState(appState);
            displayData(); // Refresh item display to update button states
            updateLockedDisplay();
            displayJson();
            return { success: true };
        },
        // Utility functions exposed for tests (to avoid duplication)
        initializeBuckets: initializeBuckets,
        migrateToBuckets: migrateToBuckets,
        updateBuckets: updateBuckets,
        calculateBucketCounts: calculateBucketCounts,
        calculateCostOfDelay: calculateCostOfDelay,
        recalculateAllCostOfDelay: recalculateAllCostOfDelay,
        calculateCD3: calculateCD3,
        recalculateAllCD3: recalculateAllCD3,
        calculateBoardPosition: calculateBoardPosition
    });
}

